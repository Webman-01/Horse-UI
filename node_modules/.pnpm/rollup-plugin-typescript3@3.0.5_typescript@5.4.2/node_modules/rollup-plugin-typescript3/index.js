"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const glob_1 = require("glob");
const typescript_1 = __importDefault(require("typescript"));
const configFilename = "tsconfig.json";
const tsExtensions = new Set([".ts", ".tsx", ".cts", ".mts"]);
const jsExtensions = {
    ".js": ".ts",
    ".jsx": ".tsx",
    ".cjs": ".cts",
    ".mjs": ".mts",
};
const compilerOptions = Object.freeze({
    importHelpers: true,
    sourceMap: true,
    module: typescript_1.default.ModuleKind.ES2022,
    moduleResolution: typescript_1.default.ModuleResolutionKind.Bundler,
});
async function getCompilerOptions(options) {
    let parsed = {
        options: {},
        errors: [],
    };
    if (options && options.compilerOptions) {
        parsed = typescript_1.default.convertCompilerOptionsFromJson(options.compilerOptions, "");
    }
    else {
        let text;
        try {
            text = await promises_1.default.readFile(configFilename, "utf-8");
        }
        catch (e) {
            if (e.code != "ENOENT")
                throw [
                    {
                        messageText: e.message,
                        category: typescript_1.default.DiagnosticCategory.Error,
                    },
                ];
        }
        if (text) {
            const result = typescript_1.default.parseConfigFileTextToJson(configFilename, text);
            if (result.error)
                throw [result.error];
            parsed = typescript_1.default.parseJsonConfigFileContent(result.config, typescript_1.default.sys, "");
        }
    }
    if (parsed.errors.length)
        throw parsed.errors;
    return Object.assign(parsed.options, compilerOptions);
}
function printDiagnostics(diagnostics, context) {
    for (const diagnostic of diagnostics) {
        const message = typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, typescript_1.default.sys.newLine);
        const file = diagnostic.file;
        const id = file ? file.fileName : null;
        const lc = file && diagnostic.start
            ? file.getLineAndCharacterOfPosition(diagnostic.start)
            : null;
        const loc = id && lc
            ? { file: id, line: lc.line + 1, column: lc.character }
            : undefined;
        if (diagnostic.category == typescript_1.default.DiagnosticCategory.Error)
            context.error({ message }, loc);
        else if (diagnostic.category == typescript_1.default.DiagnosticCategory.Warning)
            context.warn({ message }, loc);
    }
}
function isTsFile(filename) {
    return tsExtensions.has(path_1.default.extname(filename));
}
async function resolve(importee, importer) {
    const ext = path_1.default.extname(importee);
    if (!(ext in jsExtensions))
        return;
    importee = importee.replace(/\.[^.]+$/, (ext) => jsExtensions[ext]);
    const id = path_1.default.resolve(path_1.default.dirname(importer), importee);
    try {
        await promises_1.default.access(id);
        return id;
    }
    catch (e) {
        return;
    }
}
function typescript(options) {
    let input = [];
    let compilerOptions;
    let program;
    const plugin = {
        name: "typescript",
        options(inputOptions) {
            if (!inputOptions.input)
                return;
            input = Array.isArray(inputOptions.input)
                ? inputOptions.input
                : typeof inputOptions.input == "string"
                    ? [inputOptions.input]
                    : Object.values(inputOptions.input);
            return null;
        },
        async resolveId(importee, importer) {
            if (!importer || !isTsFile(importer))
                return;
            return await resolve(importee, importer);
        },
        async transform(source, id) {
            if (!isTsFile(id))
                return;
            if (!compilerOptions) {
                try {
                    compilerOptions = await getCompilerOptions(options);
                }
                catch (diagnostics) {
                    printDiagnostics(diagnostics, this);
                }
            }
            if (!program) {
                const files = await (0, glob_1.glob)("**/*.d.ts", { ignore: "node_modules/**" });
                files.push(...input);
                program = typescript_1.default.createProgram(files, compilerOptions);
            }
            const sourceFile = program.getSourceFile(id);
            if (sourceFile)
                printDiagnostics(typescript_1.default.getPreEmitDiagnostics(program, sourceFile), this);
            const output = typescript_1.default.transpileModule(source, { compilerOptions });
            return {
                code: output.outputText,
                map: output.sourceMapText ? JSON.parse(output.sourceMapText) : null,
            };
        },
    };
    return plugin;
}
module.exports = typescript;
